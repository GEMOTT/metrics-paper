---
title: "Preliminary cycling infra vs usage analysis"
format: gfm
execute: 
  echo: false
  message: false
  warning: false
  cache: true
---

## Introduction

-   Aim: examine which cycling-infrastructure metrics align best with cycling use.

-   Start with simple measures (total km, km per 1 000 people) -- foundation for later work on network characteristics.

## Data and methods

-   Cycling infrastructure from OSM, `osmactive` R package. We classified infrastructure into distinct categories using the `classify_cycle_infrastructure` function, which considers OSM tags (e.g., `highway`, `cycleway`, `segregated`) and geometry (e.g., distance to the nearest road) to distinguish between:
    -   **Segregated tracks:** Physically separated from motor traffic (further split into wide $\ge$ 2m and narrow < 2m).
    -   **Off-road paths:** Paths away from the road network (e.g., through parks).
    -   **Painted lanes:** Marked lanes on the carriageway without physical separation.
    -   **Shared footways:** Paths shared with pedestrians.
    -   **Mixed traffic:** Cycling on the carriageway with motor traffic (not counted as dedicated infrastructure).

-   Cycling use from [the EU Quality of Life Survey](https://ec.europa.eu/regional_policy/information-sources/maps/quality-of-life_en).
    83 cities, ≈ 70,000 respondents; includes a transport question (“On a typical day, which mode(s) of transport do you use most often?”
    ), where cycling is one of the selectable modes (up to two choices allowed), providing a simple city-level proxy for cycling use.
    There are previous editions.

-   Create exploratory scatter plots to see associations.

<!-- ### Potential cycling-use datasets -->

<!-- - **Eurostat: journeys to work by bicycle**   -->

<!--   Patchy coverage, many cities missing.   -->

<!--   https://ec.europa.eu/eurostat/databrowser/view/urb_ctran__custom_18909106/default/table -->

<!-- - **Bicycle counter data (Kraus and Koch, PNAS)**   -->

<!--   Only for cities with counters.   -->

<!--   https://www.pnas.org/doi/10.1073/pnas.2024399118   -->

<!--   Data: https://zenodo.org/records/4015974 -->

<!-- - **Cycling mode share in 864 European cities (Sobral et al.)**   -->

<!--   Interesting working project, modelled values.   -->

<!--   https://www.cyclingandsociety.org/wp-content/uploads/2025/09/CyclingAndSociety2025-4-Sobral.pdf -->

<!-- - **Quality of Life in European Cities survey (DG REGIO)**   -->

<!--   83 cities, >70,000 respondents; includes question   -->

<!--   “On a typical day, which mode(s) do you use most often? Bicycle”.   -->

<!--   https://ec.europa.eu/regional_policy/information-sources/maps/quality-of-life_en -->

<!-- *the QoL survey seems to provide the most consistent city-level cycling-use indicator across many cities. IS 83 sample enough?* -->

```{r}
#| label: setup
#| include: false
library(tidyverse) 
library(sf)
library(osmdata)
library(osmactive)
library(ggrepel)
library(scales)
library(knitr)   
```

```{r}
#| include: false

# install.packages("haven")  # SPSS file
library(haven)

qol <- read_sav("data/QoL in European Cities_2023_microdata/2023_QoL in European Cities_microdata.sav")

qol_factor <- qol |>
  mutate(across(where(is.labelled), ~ as_factor(.)))

qol_q5 <- qol_factor |>
  group_by(country   = Country_sample,
           city_name = D3_Cityrecode,
           population = Population) |>
  summarise(
    bike_sample = sum(w1[Q5_1 == "Bicycle" | Q5_2 == "Bicycle"], na.rm = TRUE),
    total_sample    = sum(w1, na.rm = TRUE),
    bike_prop     = bike_sample / total_sample
  ) |>
  arrange(desc(bike_prop))
```

```{r}
#| label: cities-qol
#| include: false

all_cities <- qol_q5 |>
  mutate(
    city_name = as.character(city_name),
    country   = as.character(country)
  ) |>
  arrange(desc(bike_prop))

```

```{r}
#| label: osm-cache-helpers
#| include: false
if (!dir.exists("/media/eugeni/Extrem SSD/my-stuff/metrics-paper/data")) {
  cache_dir <- "data/cache/osm_cache"
  dir.create(cache_dir, showWarnings = FALSE, recursive = TRUE)
} else {
  cache_dir <- "/media/eugeni/Extrem SSD/my-stuff/metrics-paper/data/osm_cache"
}
```

```{r}
#| label: city-tools
#| include: false
get_city_polygon <- function(city, country) {
  query <- paste(city, country, sep = ", ")
  message("  Boundary for: ", query)

  poly <- tryCatch(
    osmdata::getbb(query, format_out = "sf_polygon"),
    error = function(e) NULL
  )
  
  # Try cleaning name (e.g. Helsinki / Helsingfors -> Helsinki)
  if (is.null(poly) && grepl("/", city)) {
    clean_city <- trimws(str_split(city, "/")[[1]][1])
    query_clean <- paste(clean_city, country, sep = ", ")
    message("    Retrying with cleaned name: ", query_clean)
    poly <- tryCatch(
      osmdata::getbb(query_clean, format_out = "sf_polygon"),
      error = function(e) NULL
    )
  }

  if (inherits(poly, "sf")) {
    message("    Got polygon boundary for ", query)
    
    # FIRST: If multiple polygons returned, select the most appropriate one
    # This must happen before any geometry operations to avoid mixed type errors
    if (nrow(poly) > 1) {
      message("    Multiple polygons returned (", nrow(poly), "), selecting best one...")
      
      # Temporarily disable S2 for area calculations on mixed geometries
      s2_state <- sf::sf_use_s2()
      sf::sf_use_s2(FALSE)
      
      # Calculate areas safely for each polygon
      areas <- sapply(1:nrow(poly), function(i) {
        tryCatch(as.numeric(sf::st_area(poly[i,])) / 1e6, error = function(e) NA)
      })
      poly$area_km2 <- areas
      
      sf::sf_use_s2(s2_state)
      
      # Prefer administrative boundaries with place_rank indicating city level
      if ("place_rank" %in% names(poly)) {
        city_level <- poly |> filter(place_rank >= 15 & !is.na(area_km2))
        if (nrow(city_level) > 0) {
          poly <- city_level[which.max(city_level$area_km2), ]
          message("    Selected city-level polygon (place_rank >= 15): ", round(poly$area_km2, 2), " km sq")
        } else {
          # Fall back to polygon with area between 10-500 km² (typical city size)
          city_sized <- poly |> filter(area_km2 >= 10 & area_km2 <= 500 & !is.na(area_km2))
          if (nrow(city_sized) > 0) {
            poly <- city_sized[which.max(city_sized$area_km2), ]
            message("    Selected city-sized polygon: ", round(poly$area_km2, 2), " km sq")
          } else {
            # Just take the first row (usually the primary result)
            poly <- poly[1, ]
            message("    Using first polygon result")
          }
        }
      } else {
        # No place_rank, use area heuristics or just first row
        city_sized <- poly |> filter(area_km2 >= 10 & area_km2 <= 500 & !is.na(area_km2))
        if (nrow(city_sized) > 0) {
          poly <- city_sized[which.max(city_sized$area_km2), ]
          message("    Selected city-sized polygon: ", round(poly$area_km2, 2), " km sq")
        } else {
          poly <- poly[1, ]
          message("    Using first polygon result")
        }
      }
      poly$area_km2 <- NULL  # Remove temporary column
    }
    
    # THEN: Ensure valid geometry (now working with single polygon)
    poly <- tryCatch({
      sf::st_make_valid(poly)
    }, error = function(e) {
      message("    Warning: st_make_valid failed, using original")
      poly
    })
  } else {
    message("    No polygon boundary for ", query, "; trying bounding box")
    bb <- osmdata::getbb(query)
    if (is.null(bb) && grepl("/", city)) {
       clean_city <- trimws(str_split(city, "/")[[1]][1])
       query_clean <- paste(clean_city, country, sep = ", ")
       bb <- osmdata::getbb(query_clean)
    }
    
    if (is.null(bb)) {
      warning("    No boundary found for ", query)
      return(NULL)
    }

    poly <- sf::st_as_sf(
      sf::st_sfc(
        sf::st_polygon(list(rbind(
          c(bb["x", "min"], bb["y", "min"]),
          c(bb["x", "min"], bb["y", "max"]),
          c(bb["x", "max"], bb["y", "max"]),
          c(bb["x", "max"], bb["y", "min"]),
          c(bb["x", "min"], bb["y", "min"])
        ))),
        crs = 4326
      )
    )
  }

  # Calculate area
  area_sq_km <- sum(as.numeric(sf::st_area(poly))) / 1e6

  message("    Area: ", round(area_sq_km, 2), " km sq")
  
  # Check if area is suspiciously small (e.g. < 5 km sq for a major city)
  # Helsinki was 0.13 km sq.
  if (area_sq_km < 2 && grepl("/", city)) {
     message("    Area very small for split name. Trying cleaned name...")
     clean_city <- trimws(str_split(city, "/")[[1]][1])
     query_clean <- paste(clean_city, country, sep = ", ")
     poly_clean <- tryCatch(
      osmdata::getbb(query_clean, format_out = "sf_polygon"),
      error = function(e) NULL
     )
     if (inherits(poly_clean, "sf")) {
       area_clean <- sum(as.numeric(sf::st_area(poly_clean))) / 1e6
       if (area_clean > area_sq_km) {
         message("    Using cleaned name polygon (Area: ", round(area_clean, 2), " km sq)")
         poly <- poly_clean
         area_sq_km <- area_clean
       }
     }
  }

  if (area_sq_km > 1000) {
    message("    Area > 1000 km sq. Clipping to 25km radius from centroid.")

    # Find centroid of the union (in case of multiple polygons)
    centroid <- sf::st_centroid(sf::st_union(poly))

    # Create 25km buffer
    buffer <- sf::st_buffer(centroid, dist = 25000)

    # Intersect
    poly <- sf::st_intersection(poly, buffer)
  }

  return(poly)
}

get_city_metrics <- function(city_name, country_name) {
  message("=== City: ", city_name, ", ", country_name, " ===")
  
  # Ensure cache dir exists (helper check)
  cache_dir <- "data/cache/osm_cache"
  if (!dir.exists(cache_dir)) dir.create(cache_dir, recursive = TRUE, showWarnings = FALSE)
  
  # Define cache paths with sanitized names
  safe_city <- gsub("[^A-Za-z0-9]", "_", city_name)
  safe_country <- gsub("[^A-Za-z0-9]", "_", country_name)
  
  osm_path <- file.path(cache_dir, paste0("osm_", safe_country, "_", safe_city, ".rds"))
  cycle_path <- file.path(cache_dir, paste0("cycle_", safe_country, "_", safe_city, ".rds"))

  poly <- get_city_polygon(city_name, country_name)
  if (is.null(poly)) {
    return(tibble(
      country           = country_name,
      city_name         = city_name,
      total_cycle_km    = NA_real_,
      total_road_km     = NA_real_,
      off_road_km       = NA_real_,
      segregated_wide_km = NA_real_,
      segregated_narrow_km = NA_real_,
      painted_km        = NA_real_,
      shared_footway_km = NA_real_,
      high_los_km       = NA_real_
    ))
  }

  # 1. Get/Load OSM Data
  if (file.exists(osm_path)) {
    message("  Reading cached OSM from ", osm_path)
    osm_city <- readRDS(osm_path)
  } else {
    # Download/extract OSM for just this city area
    # Use polygon directly so osmextract auto-selects correct regional PBF
    
    # Temporarily disable S2 to avoid "loop" errors with osmactive/geos
    sf::sf_use_s2(FALSE)
    osm_city <- tryCatch({
      # Use place = poly so osmextract finds the right sub-region PBF file
      # (e.g., île-de-france for Paris instead of all of France)
      net <- osmactive::get_travel_network(place = poly)
      if (!is.null(net)) {
        # Now clip to exact polygon
        sf::st_intersection(net, poly)
      } else {
        NULL
      }
    }, error = function(e) {
      warning("Failed to get OSM for ", city_name, ": ", e$message)
      return(NULL)
    })
    sf::sf_use_s2(TRUE)
    
    if (!is.null(osm_city)) {
      message("  Saving OSM to ", osm_path)
      saveRDS(osm_city, osm_path)
    }
  }
  
  if (is.null(osm_city)) {
    return(tibble(
      country           = country_name,
      city_name         = city_name,
      total_cycle_km    = NA_real_,
      total_road_km     = NA_real_,
      off_road_km       = NA_real_,
      segregated_wide_km = NA_real_,
      segregated_narrow_km = NA_real_,
      painted_km        = NA_real_,
      shared_footway_km = NA_real_,
      high_los_km       = NA_real_
    ))
  }

  # 2. Get/Load Cycling Network
  if (file.exists(cycle_path)) {
     message("  Reading cached Cycle net from ", cycle_path)
     cyc_city <- readRDS(cycle_path)
  } else {
    # Get cycling network
    cyc_city <- osmactive::get_cycling_network(osm_city)
    
    # Identify car roads for distance calculation (from the same city extract)
    car_roads_city <- osm_city |>
      filter(highway %in% c("motorway", "motorway_link", "trunk", "trunk_link", 
                            "primary", "primary_link", "secondary", "secondary_link", 
                            "tertiary", "tertiary_link", "unclassified", "residential"))
  
    # Calculate distance to nearest road
    if (nrow(cyc_city) > 0) {
      if (nrow(car_roads_city) > 0) {
        pts <- sf::st_point_on_surface(cyc_city)
        nearest_idx <- sf::st_nearest_feature(pts, car_roads_city)
        dists <- sf::st_distance(pts, car_roads_city[nearest_idx,], by_element = TRUE)
        cyc_city$distance_to_road <- as.numeric(dists)
      } else {
        cyc_city$distance_to_road <- 0 
      }
    }
    
    message("  Saving Cycle net to ", cycle_path)
    saveRDS(cyc_city, cycle_path)
  }
  
  # Calculate total road length if not already done
  # We can do this from car_roads_city if available, or load OSM if needed
  # Since we are inside the function, we might have skipped loading OSM if cycle path existed
  # But we need OSM for roads.
  # Check if we have car_roads_city variable.
  if (!exists("car_roads_city")) {
     # If we loaded cycle path from cache, we didn't load OSM.
     # We need to load OSM to get roads.
     # But wait, if we load OSM every time, we lose the benefit of cycle cache for speed?
     # Yes. But we need to calculate this new metric once.
     if (file.exists(osm_path)) {
        osm_city <- readRDS(osm_path)
        car_roads_city <- osm_city |>
          filter(highway %in% c("motorway", "motorway_link", "trunk", "trunk_link", 
                                "primary", "primary_link", "secondary", "secondary_link", 
                                "tertiary", "tertiary_link", "unclassified", "residential"))
     } else {
       # Should have been created/loaded above?
       # The logic above: if cycle_path exists, it DOES NOT load OSM.
       # So we must load OSM here if it's missing.
       # (See logic: if (file.exists(cycle_path)) ... else ... )
       # To fix: ensure OSM is loaded if we need road stats.
       # For now, I will just load it.
       # This is safe because I save osm_path before cycle_path.
        osm_city <- readRDS(osm_path)
        car_roads_city <- osm_city |>
          filter(highway %in% c("motorway", "motorway_link", "trunk", "trunk_link", 
                                "primary", "primary_link", "secondary", "secondary_link", 
                                "tertiary", "tertiary_link", "unclassified", "residential"))
     }
  }
  
  # Calculate total road length
  car_roads_city$length_m <- sf::st_length(car_roads_city)
  total_road_km <- round(sum(as.numeric(car_roads_city$length_m), na.rm = TRUE) / 1000, 2)

  # --- New LoS calculation section ---
  message("  Calculating LoS...")
  # Standardize for osmactive functions
  osm_city_prep = osm_city |>
    dplyr::filter(highway %in% c("motorway", "motorway_link", "trunk", "trunk_link", 
                          "primary", "primary_link", "secondary", "secondary_link", 
                          "tertiary", "tertiary_link", "unclassified", "residential", "living_street", "service"))
  
  if (nrow(osm_city_prep) > 0) {
    # Get cycle info for the whole network
    osm_city_prep = osm_city_prep |>
      dplyr::mutate(
        cycle_segregation = osmactive::classify_cycle_infrastructure(
          osmactive::distance_to_road(cyc_city, osm_city_prep),
          include_mixed_traffic = TRUE
        )$cycle_segregation[sf::st_nearest_feature(osm_city_prep, cyc_city)]
      ) |>
      dplyr::mutate(infrastructure = cycle_segregation)
    
    # Estimate traffic and LoS
    # Note: osmactive::level_of_service calls estimate_traffic() internally if AADT is missing
    osm_los = tryCatch({
      osmactive::level_of_service(osm_city_prep)
    }, error = function(e) {
      message("    LoS error: ", e$message)
      NULL
    })
    
    if (!is.null(osm_los)) {
      osm_los$length_m = sf::st_length(osm_los)
      high_los_km = round(sum(as.numeric(osm_los$length_m[osm_los$`Level of Service` == "High"]), na.rm = TRUE) / 1000, 2)
    } else {
      high_los_km = 0
    }
  } else {
    high_los_km = 0
  }
  # --- End LoS section ---

  if (nrow(cyc_city) == 0) {
    return(tibble(
      country           = country_name,
      city_name         = city_name,
      total_cycle_km    = 0,
      total_road_km     = total_road_km,
      off_road_km       = 0,
      segregated_wide_km = 0,
      segregated_narrow_km = 0,
      painted_km        = 0,
      shared_footway_km = 0,
      high_los_km       = high_los_km
    ))
  }

  # Classify
  cyc_classified <- tryCatch({
    osmactive::classify_cycle_infrastructure(cyc_city)
  }, error = function(e) {
    warning("Classification failed for ", city_name, ": ", e$message)
    cyc_city$cycle_segregation <- NA_character_
    cyc_city
  })

  # Calculate lengths
  cyc_classified$length_m <- sf::st_length(cyc_classified)
  
  # Summarise
  summary <- cyc_classified |>
    sf::st_drop_geometry() |>
    group_by(cycle_segregation) |>
    summarise(len_km = sum(as.numeric(length_m), na.rm = TRUE) / 1000) |>
    ungroup()
  
  get_len <- function(cat) {
    val <- summary$len_km[summary$cycle_segregation == cat]
    if (length(val) == 0 || is.na(val)) 0 else val
  }

  tibble(
    country           = country_name,
    city_name         = city_name,
    total_cycle_km    = round(sum(as.numeric(cyc_classified$length_m), na.rm = TRUE) / 1000, 2),
    total_road_km     = total_road_km,
    off_road_km       = round(get_len("Off Road Path"), 2),
    segregated_wide_km = round(get_len("Segregated Track (wide)"), 2),
    segregated_narrow_km = round(get_len("Segregated Track (narrow)"), 2),
    painted_km        = round(get_len("Painted Cycle Lane"), 2),
    shared_footway_km = round(get_len("Shared Footway"), 2),
    high_los_km       = high_los_km
  )
}

```

```{r}
#| label: download-and-update-city-lengths
#| eval: false
#| include: false

# 0. All cities present in the QoL data
cities_all <- all_cities |>
  select(country, city_name) |>
  distinct() |>
  mutate(across(everything(), as.character)) |>
  arrange(country, city_name)

# 1. Load previous city lengths if they exist
if (file.exists("outputs/city_lengths_all.csv")) {
  city_lengths_all <- read_csv("outputs/city_lengths_all.csv", show_col_types = FALSE) |>
    mutate(across(where(is.numeric), ~ round(., 2)))
  cols_to_add <- c("total_road_km", "off_road_km", "segregated_wide_km", "segregated_narrow_km", "painted_km", "shared_footway_km", "high_los_km")
  for (col in cols_to_add) {
    if (!col %in% names(city_lengths_all)) {
      city_lengths_all[[col]] <- NA_real_
    }
  }
} else {
  city_lengths_all <- tibble(
    country           = character(),
    city_name         = character(),
    total_cycle_km    = numeric(),
    total_road_km     = numeric(),
    off_road_km       = numeric(),
    segregated_wide_km = numeric(),
    segregated_narrow_km = numeric(),
    painted_km        = numeric(),
    shared_footway_km = numeric(),
    high_los_km       = numeric()
  )
}

# 2. Work out which cities already have lengths in the RDS (with new columns)
# Check for high_los_km to ensure we have the latest metrics
if ("high_los_km" %in% names(city_lengths_all)) {
  cities_done <- city_lengths_all |>
    filter(!is.na(high_los_km)) |>
    select(country, city_name)
} else {
  cities_done <- tibble(country = character(), city_name = character())
}

cities_todo <- cities_all |>
  anti_join(cities_done, by = c("country", "city_name"))

message("Cities to process: ", nrow(cities_todo))

# 3. Loop over remaining cities, saving as we go
if (nrow(cities_todo) > 0) {
  dir.create("outputs", showWarnings = FALSE)

  start_time <- Sys.time()
  
  for (i in seq_len(nrow(cities_todo))) {
    cty <- cities_todo$country[i]
    city <- cities_todo$city_name[i]
    
    res <- try({
      get_city_metrics(city, cty)
    }, silent = TRUE)

    if (inherits(res, "try-error")) {
      warning("Failed for ", city, ": ", conditionMessage(attr(res, "condition")))
      next
    }
    
    if (is.null(res)) next

    # Update combined table and save after each city
    city_lengths_all <- city_lengths_all |>
        filter(!(country == cty & city_name == city)) |>
        bind_rows(res)

    write_csv(city_lengths_all, "outputs/city_lengths_all.csv")
    message("Saved updated city_lengths_all.csv")
  }
  
  end_time <- Sys.time()
  timing_msg <- paste0("Processed ", nrow(cities_todo), " cities in ", round(as.numeric(difftime(end_time, start_time, units = "secs")), 2), " seconds.")
  message(timing_msg)
} else {
  message("No new cities to process. All done.")
}
city_lengths_all
```

```{r}
#| label: test-classification
#| eval: false

# Test the classification logic on a small country/city (Monaco)
message("Running classification test for Monaco...")
# We use try() to allow the document to render even if the test fails (e.g. internet issues)
test_result <- try({
  get_city_metrics("Monaco", "Monaco")
}, silent = TRUE)

if (inherits(test_result, "try-error")) {
  message("Test failed: ", conditionMessage(attr(test_result, "condition")))
} else {
  print(test_result)
}
```

```{r}
#| label: tbl-qol-cities
top_3 <- all_cities |> head(3)
bottom_3 <- all_cities |> tail(3)
middle_rows_indices = 4:(nrow(all_cities) - 3)
middle_rows <- all_cities[middle_rows_indices, ]
set.seed(42)
middle_3 <- middle_rows |>
  ungroup() |>
  sample_n(3)

bind_rows(top_3, middle_3, bottom_3) |>
  arrange(desc(bike_prop)) |>
  mutate(bike_prop = scales::percent(bike_prop, accuracy = 0.1)) |>
  select(country, city_name, bike_prop, sample_size = total_sample) |>
  knitr::kable(caption = "Top 3, bottom 3 and 3 random middle cities by cycling levels")
```

## Results

```{r}
#| label: analysis-test
#| include: false

test_countries <- c(
  "Albania",
  "Austria",
  "Belgium",
  "Bulgaria",
  "Croatia",
  "Cyprus",
  "Czech Republic",
  "Denmark",
  "Estonia",
  "Finland",
  "France",
  "Greece",
  "Hungary",
  "Iceland",
  "Ireland",
  "Italy",
  "Latvia",
  "Lithuania",
  "Luxembourg",
  "Macedonia",
  "Malta",
  "Montenegro",
  "Netherlands",
  "Poland",
  "Portugal",
  "Romania",
  "Serbia",
  "Slovakia",
  "Slovenia",
  "Spain",
  "Sweden",
  "Switzerland",
  "Turkey")

# Region mapping (UN Geoscheme-inspired)
region_mapping <- c(
  "Denmark" = "Northern", "Estonia" = "Northern", "Finland" = "Northern", 
  "Iceland" = "Northern", "Ireland" = "Northern", "Latvia" = "Northern", 
  "Lithuania" = "Northern", "Sweden" = "Northern", "United Kingdom" = "Northern",
  
  "Austria" = "Western", "Belgium" = "Western", "France" = "Western", 
  "Germany" = "Western", "Luxembourg" = "Western", "Netherlands" = "Western", 
  "Switzerland" = "Western",
  
  "Albania" = "Southern", "Croatia" = "Southern", "Cyprus" = "Southern", 
  "Greece" = "Southern", "Italy" = "Southern", "Malta" = "Southern", 
  "Montenegro" = "Southern", "Portugal" = "Southern", "Serbia" = "Southern", 
  "Slovenia" = "Southern", "Spain" = "Southern", "Macedonia" = "Southern", 
  "Turkey" = "Southern",
  
  "Bulgaria" = "Eastern", "Czech Republic" = "Eastern", "Hungary" = "Eastern", 
  "Poland" = "Eastern", "Romania" = "Eastern", "Slovakia" = "Eastern"
)

test_cities <- all_cities |>
  filter(country %in% test_countries)

dir.create("outputs", showWarnings = FALSE)

if (file.exists("outputs/city_lengths_all_v3.csv")) {
  city_lengths_all <- read_csv("outputs/city_lengths_all_v3.csv", show_col_types = FALSE)
} else if (file.exists("outputs/city_lengths_all_v2.csv")) {
  city_lengths_all <- read_csv("outputs/city_lengths_all_v2.csv", show_col_types = FALSE)
} else {
  city_lengths_all <- read_csv("outputs/city_lengths_all.csv", show_col_types = FALSE)
}

analysis_test <- test_cities |>
  left_join(
    city_lengths_all,
    by = c("country", "city_name")
  ) |>
  mutate(
    bike_share_pct    = bike_prop * 100,
    infra_km_per_1000 = total_cycle_km / (population / 1000),
    Region = region_mapping[country]
  ) |>
  mutate(Region = ifelse(is.na(Region), "Other", Region))

analysis_test |>
  select(country, Region, city_name, population, bike_share_pct, infra_km_per_1000)
```

```{r}
#| label: fig-infra-usage-types
#| echo: false
#| message: false
#| warning: false
#| paged-print: false
#| fig-cap: "Relationship between cycling mode share and different types of cycling infrastructure (as a percentage of the total road network), colored by European region."

# Prepare data for plotting
plot_data <- analysis_test |>
  filter(
    !is.na(total_road_km),
    !is.na(bike_share_pct),
    population > 100000,
    country != "Turkey",
    total_road_km > 0
  ) |>
  mutate(
    segregated_km = segregated_wide_km + segregated_narrow_km
  )

# Create long format for faceting
plot_data_long <- plot_data |>
  # Select relevant columns
  transmute(
    city_name,
    Region,
    bike_share_pct,
    population,
    total_road_km,
    off_road_km,
    segregated_km,
    painted_km,
    shared_footway_km,
    high_los_km,
    high_medium_los_km = high_los_km + painted_km
  ) |>
  pivot_longer(
    cols = c(off_road_km, segregated_km, painted_km, shared_footway_km, high_los_km, high_medium_los_km),
    names_to = "infra_type",
    values_to = "km"
  ) |>
  mutate(
    pct_network = (km / total_road_km) * 100,
    infra_type_label = factor(infra_type, 
      levels = c("segregated_km", "off_road_km", "painted_km", "shared_footway_km", "high_los_km", "high_medium_los_km"),
      labels = c("Segregated tracks", "Off-road paths", "Painted lanes", "Shared footways", "High LoS (Very Safe)", "Low Stress (High/Med LoS)")
    )
  )

# Calculate R-squared values associated with each infrastructure type with dplyr nest/map
cor_data <- plot_data_long |>
  group_by(infra_type_label) |>
  summarise(
    n_cities   = n(),
    correlation = cor(pct_network, bike_share_pct, use = "complete.obs"),
    r_squared  = cor(pct_network, bike_share_pct, use = "complete.obs")^2
  ) |>
  ungroup()

cor_data_labels <- cor_data |>
  mutate(
    label_text = paste0(
      infra_type_label, "\n",
      "R² = ", round(r_squared, 2), 
      " (n = ", n_cities, ")"
    )
  ) |>
  select(infra_type_label, label_text)

# Join R2 labels back to plot data
plot_data_long <- plot_data_long |>
  left_join(cor_data_labels, by = "infra_type_label")

set.seed(123)

scatter_plot <- ggplot(
  plot_data_long,
  aes(
    x      = pct_network,
    y      = bike_share_pct,
    size   = population,
    colour = Region
  )
) +
  geom_point(alpha = 0.6) +
  geom_smooth(method = "lm", se = FALSE,
              colour = "grey40", linewidth = 0.5, linetype = "dashed") +
  facet_wrap(~label_text, scales = "free_x") +
  ggrepel::geom_text_repel(
    aes(label = city_name),
    size         = 2.5,
    show.legend  = FALSE,
    max.overlaps = 10
  ) +
  scale_size_continuous(
    name   = "Population",
    labels = scales::label_number(scale_cut = scales::cut_short_scale()),
    range  = c(1, 4),
    guide  = guide_legend(override.aes = list(alpha = 1, colour = "grey60"))
  ) +
  labs(
    x = "Infrastructure (% of total road network)",
    y = "Cycling mode share (%)",
    colour = "Region",
    title  = "Cycling levels vs. Infrastructure Composition"
  ) +
  theme_minimal(base_size = 11) +
  theme(
    plot.title       = element_text(face = "bold"),
    panel.grid.minor = element_blank(),
    legend.position  = "bottom",
    strip.text       = element_text(face = "bold")
  )

# scatter_plot

dir.create("figs", showWarnings = FALSE)
ggsave("figs/scatter_plot.png", bg = "white", width = 10, height = 7)
r2_vals <- setNames(cor_data$r_squared, cor_data$infra_type_label)
r_vals <- setNames(round(cor_data$correlation, 2), cor_data$infra_type_label)

# Highlight top cities for High LoS
top_high_los <- plot_data |>
  mutate(high_los_pct = (high_los_km / total_road_km) * 100) |>
  arrange(desc(high_los_pct)) |>
  select(city_name, country, high_los_pct, bike_share_pct) |>
  head(10)

# It's showing Irakleio as highest by high LoS
# TODO: investigate why
# knitr::kable(top_high_los, caption = "Top 10 cities by Percentage of High Level of Service (Low Stress) Network.")
```

```{r}
#| label: fig-scatter-plot
#| fig-cap: "Scatter plots showing the relationship between cycling mode share and different types of cycling infrastructure (as a percentage of the total road network), colored by European region."
knitr::include_graphics("figs/scatter_plot.png")
```

The analysis reveals varying degrees of association between infrastructure types and cycling levels when normalized by the total road network. Segregated tracks show a strong correlation of $R^2 =$ `r r2_vals["Segregated tracks"]`. 

Surprisingly, the **Low Stress (High/Med LoS)** network shows a weak negative correlation ($r = `r r_vals["Low Stress (High/Med LoS)"]`$). This suggests that a high proportion of low-traffic residential streets does not automatically lead to high cycling levels. In many cases, cities with very high percentages of "low stress" streets are lower-density urban areas where these streets lack the connectivity or dedicated infrastructure on major corridors needed to make cycling a viable transport option across the city.

## Discussion

The analysis reveals a clear hierarchy in the relationship between infrastructure types and cycling levels. **Segregated tracks** demonstrate the strongest positive correlation with cycling mode share ($R^2 \approx 0.39$), supporting the hypothesis that physical separation from motor traffic is the single most important infrastructure feature enabling higher cycling levels.

The findings for the **Low Stress** network are particularly telling. The lack of a positive correlation suggests that merely "reducing bad infrastructure" (i.e., having many quiet streets) is insufficient for driving modal shift. Successful cycling cities are characterized not just by quiet backstreets, but by high-quality, protected interventions on the main road networks where travel demand is highest.

In contrast, **painted lanes** show negligible correlation ($R^2 \approx 0.01$), reinforcing the growing consensus that markings without protection are insufficient to encourage significant increases in cycling.

### Limitations

-   **Data Completeness:** Data retrieval was successful for `r nrow(filter(analysis_test, !is.na(total_road_km)))` out of `r nrow(analysis_test)` cities. Some cities (particularly in France and Spain) are missing due to data provider issues.
-   **OSM Quality:** The analysis relies on OpenStreetMap data completeness and tagging consistency, which varies by region.
-   **Causality:** This cross-sectional analysis establishes correlation, not causality. High cycling levels might drive investment in infrastructure, or vice versa.

## Conclusion

This preliminary analysis suggests that cities aiming to increase cycling mode share should prioritize the development of **segregated cycling infrastructure**. While paint and shared paths provide connectivity, they do not show the same strong relationship with high cycling usage observed for physically separated tracks. Future work should focus on network connectivity metrics and control for other factors like topography and climate.

## Next steps

-   Investigate missing data for France and Spain.
-   Expand metrics to include network connectivity (e.g., mesh density, directness).
-   Fit multivariate regression models including controls.