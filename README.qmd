---
format: gfm
execute: 
  echo: true
  warning: false
  message: false
---

This repo contains reproducible code to support a paper on measuring cycling network quality.

The aim is to compare different ways of measuring cycle network quality between major cities and to evaluate these measures against actual cycling usage data.

The starting point is Paris so we will focus on that city first.

We can put everything in this REAMDE.qmd file for now, and arrange the repo structure later.


```{r}
#| label: setup
remotes::install_github("nptscot/osmactive")
library(osmactive)
library(tidyverse)
```



```{r}
#| label: load-data
osm = get_travel_network("Paris")
cycle_net = get_cycling_network(osm)
drive_net = get_driving_network(osm)
cycle_net_d = distance_to_road(cycle_net, drive_net)
cycle_net_c = classify_cycle_infrastructure(cycle_net_d, include_mixed_traffic = TRUE)
m = plot_osm_tmap(cycle_net_c)
# m
plot(cycle_net_c["cycle_segregation"])
```

We can calculate a measures of cycle network quality just from this:

```{r}
# names(cycle_net_c)
cycle_net_c$length_m = sf::st_length(cycle_net_c)
total_network_length = sum(cycle_net_c$length_m)
city_metrics_1 = cycle_net_c |>
  sf::st_drop_geometry() |>
  # Keep only rows in which cycle_segregation contains "path|track":
  filter(str_detect(cycle_segregation, "ath|rack")) |>
  group_by(cycle_segregation) |>
  summarise(total_length_m = sum(length_m)) |>
  transmute(metric = cycle_segregation, percentage = round(total_length_m / total_network_length * 100))
city_metrics_2 = cycle_net_c |>
  sf::st_drop_geometry() |>
  filter(str_detect(cycle_segregation, "ath|rack")) |>
  group_by(cycle_segregation = "Protected") |>
  summarise(total_length_m = sum(length_m)) |>
  transmute(metric = cycle_segregation, percentage = round(total_length_m / total_network_length * 100))
city_metrics_combined = bind_rows(city_metrics_1, city_metrics_2) |>
  arrange(desc(percentage))
```

The first three metrics for Paris are:

```{r}
knitr::kable(city_metrics_combined)
```

The next step is to estimate level of service with the following function:

```{r}
osmactive::level_of_service
```