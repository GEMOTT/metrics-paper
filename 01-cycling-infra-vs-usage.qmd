---
title: "Preliminary cycling infra vs usage analysis"
format: gfm
---

## Introduction

-   Aim: examine which cycling-infrastructure metrics align best with cycling use.

-   Start with simple measures (total km, km per 1 000 people) -- foundation for later work on network characteristics.

## Data and methods

-   Cycling infrastructure from OSM, `osmactive` R package. We classified infrastructure into distinct categories using the `classify_cycle_infrastructure` function, which considers OSM tags (e.g., `highway`, `cycleway`, `segregated`) and geometry (e.g., distance to the nearest road) to distinguish between:
    -   **Segregated tracks:** Physically separated from motor traffic (further split into wide $\ge$ 2m and narrow < 2m).
    -   **Off-road paths:** Paths away from the road network (e.g., through parks).
    -   **Painted lanes:** Marked lanes on the carriageway without physical separation.
    -   **Shared footways:** Paths shared with pedestrians.
    -   **Mixed traffic:** Cycling on the carriageway with motor traffic (not counted as dedicated infrastructure).

-   Cycling use from [the EU Quality of Life Survey](https://ec.europa.eu/regional_policy/information-sources/maps/quality-of-life_en).
    83 cities, ≈ 70,000 respondents; includes a transport question (“On a typical day, which mode(s) of transport do you use most often?”
    ), where cycling is one of the selectable modes (up to two choices allowed), providing a simple city-level proxy for cycling use.
    There are previous editions.

-   Create exploratory scatter plots to see associations.

<!-- ### Potential cycling-use datasets -->

<!-- - **Eurostat: journeys to work by bicycle**   -->

<!--   Patchy coverage, many cities missing.   -->

<!--   https://ec.europa.eu/eurostat/databrowser/view/urb_ctran__custom_18909106/default/table -->

<!-- - **Bicycle counter data (Kraus and Koch, PNAS)**   -->

<!--   Only for cities with counters.   -->

<!--   https://www.pnas.org/doi/10.1073/pnas.2024399118   -->

<!--   Data: https://zenodo.org/records/4015974 -->

<!-- - **Cycling mode share in 864 European cities (Sobral et al.)**   -->

<!--   Interesting working project, modelled values.   -->

<!--   https://www.cyclingandsociety.org/wp-content/uploads/2025/09/CyclingAndSociety2025-4-Sobral.pdf -->

<!-- - **Quality of Life in European Cities survey (DG REGIO)**   -->

<!--   83 cities, >70,000 respondents; includes question   -->

<!--   “On a typical day, which mode(s) do you use most often? Bicycle”.   -->

<!--   https://ec.europa.eu/regional_policy/information-sources/maps/quality-of-life_en -->

<!-- *the QoL survey seems to provide the most consistent city-level cycling-use indicator across many cities. IS 83 sample enough?* -->

```{r}
#| label: setup
#| include: false
library(tidyverse) 
library(sf)
library(osmdata)
library(osmactive)
library(ggrepel)
library(scales)
library(knitr)   
```

```{r}
#| include: false

# install.packages("haven")  # SPSS file
library(haven)

qol <- read_sav("data/QoL in European Cities_2023_microdata/2023_QoL in European Cities_microdata.sav")

qol_factor <- qol |>
  mutate(across(where(is.labelled), ~ as_factor(.)))

qol_q5 <- qol_factor |>
  group_by(country   = Country_sample,
           city_name = D3_Cityrecode,
           population = Population) |>
  summarise(
    bike_sample = sum(w1[Q5_1 == "Bicycle" | Q5_2 == "Bicycle"], na.rm = TRUE),
    total_sample    = sum(w1, na.rm = TRUE),
    bike_prop     = bike_sample / total_sample
  ) |>
  arrange(desc(bike_prop))
```

```{r}
#| label: cities-qol
#| include: false

all_cities <- qol_q5 |>
  mutate(
    city_name = as.character(city_name),
    country   = as.character(country)
  ) |>
  arrange(desc(bike_prop))

```

```{r}
#| label: osm-cache-helpers
#| include: false
if (!dir.exists("/media/eugeni/Extrem SSD/my-stuff/metrics-paper/data")) {
  cache_dir <- "data/cache/osm_cache"
  dir.create(cache_dir, showWarnings = FALSE, recursive = TRUE)
} else {
  cache_dir <- "/media/eugeni/Extrem SSD/my-stuff/metrics-paper/data/osm_cache"
}



```

```{r}
#| label: city-tools
#| include: false
get_city_polygon <- function(city, country) {
  query <- paste(city, country, sep = ", ")
  message("  Boundary for: ", query)

  poly <- tryCatch(
    osmdata::getbb(query, format_out = "sf_polygon"),
    error = function(e) NULL
  )

  if (inherits(poly, "sf")) {
    message("    Got polygon boundary for ", query)
  } else {
    message("    No polygon boundary for ", query, "; trying bounding box")
    bb <- osmdata::getbb(query)
    if (is.null(bb)) {
      warning("    No boundary found for ", query)
      return(NULL)
    }

    poly <- sf::st_as_sf(
      sf::st_sfc(
        sf::st_polygon(list(rbind(
          c(bb["x", "min"], bb["y", "min"]),
          c(bb["x", "min"], bb["y", "max"]),
          c(bb["x", "max"], bb["y", "max"]),
          c(bb["x", "max"], bb["y", "min"]),
          c(bb["x", "min"], bb["y", "min"])
        ))),
        crs = 4326
      )
    )
  }

  # Calculate area
  area_sq_km <- sum(as.numeric(sf::st_area(poly))) / 1e6

  message("    Area: ", round(area_sq_km, 2), " km sq")

  if (area_sq_km > 1000) {
    message("    Area > 1000 km sq. Clipping to 25km radius from centroid.")

    # Find centroid of the union (in case of multiple polygons)
    centroid <- sf::st_centroid(sf::st_union(poly))

    # Create 25km buffer
    buffer <- sf::st_buffer(centroid, dist = 25000)

    # Intersect
    poly <- sf::st_intersection(poly, buffer)
  }

  return(poly)
}

get_city_metrics <- function(city_name, country_name) {
  message("=== City: ", city_name, ", ", country_name, " ===")
  
  # Ensure cache dir exists (helper check)
  cache_dir <- "data/cache/osm_cache"
  if (!dir.exists(cache_dir)) dir.create(cache_dir, recursive = TRUE, showWarnings = FALSE)
  
  # Define cache paths with sanitized names
  safe_city <- gsub("[^A-Za-z0-9]", "_", city_name)
  safe_country <- gsub("[^A-Za-z0-9]", "_", country_name)
  
  osm_path <- file.path(cache_dir, paste0("osm_", safe_country, "_", safe_city, ".rds"))
  cycle_path <- file.path(cache_dir, paste0("cycle_", safe_country, "_", safe_city, ".rds"))

  poly <- get_city_polygon(city_name, country_name)
  if (is.null(poly)) {
    return(tibble(
      country           = country_name,
      city_name         = city_name,
      total_cycle_km    = NA_real_,
      off_road_km       = NA_real_,
      segregated_wide_km = NA_real_,
      segregated_narrow_km = NA_real_,
      painted_km        = NA_real_,
      shared_footway_km = NA_real_
    ))
  }

  # 1. Get/Load OSM Data
  if (file.exists(osm_path)) {
    message("  Reading cached OSM from ", osm_path)
    osm_city <- readRDS(osm_path)
  } else {
    # Download/extract OSM for just this city area
    # Using boundary=poly ensures we only load relevant data into RAM
    # Temporarily disable S2 to avoid "loop" errors with osmactive/geos
    sf::sf_use_s2(FALSE)
    osm_city <- tryCatch({
      osmactive::get_travel_network(place = country_name, boundary = poly)
    }, error = function(e) {
      warning("Failed to get OSM for ", city_name, ": ", e$message)
      return(NULL)
    })
    sf::sf_use_s2(TRUE)
    
    if (!is.null(osm_city)) {
      message("  Saving OSM to ", osm_path)
      saveRDS(osm_city, osm_path)
    }
  }
  
  if (is.null(osm_city)) {
    return(tibble(
      country           = country_name,
      city_name         = city_name,
      total_cycle_km    = NA_real_,
      off_road_km       = NA_real_,
      segregated_wide_km = NA_real_,
      segregated_narrow_km = NA_real_,
      painted_km        = NA_real_,
      shared_footway_km = NA_real_
    ))
  }

  # 2. Get/Load Cycling Network
  if (file.exists(cycle_path)) {
     message("  Reading cached Cycle net from ", cycle_path)
     cyc_city <- readRDS(cycle_path)
  } else {
    # Get cycling network
    cyc_city <- osmactive::get_cycling_network(osm_city)
    
    # Identify car roads for distance calculation (from the same city extract)
    car_roads_city <- osm_city |>
      filter(highway %in% c("motorway", "motorway_link", "trunk", "trunk_link", 
                            "primary", "primary_link", "secondary", "secondary_link", 
                            "tertiary", "tertiary_link", "unclassified", "residential"))
  
    # Calculate distance to nearest road
    if (nrow(cyc_city) > 0) {
      if (nrow(car_roads_city) > 0) {
        pts <- sf::st_point_on_surface(cyc_city)
        nearest_idx <- sf::st_nearest_feature(pts, car_roads_city)
        dists <- sf::st_distance(pts, car_roads_city[nearest_idx,], by_element = TRUE)
        cyc_city$distance_to_road <- as.numeric(dists)
      } else {
        cyc_city$distance_to_road <- 0 
      }
    }
    
    message("  Saving Cycle net to ", cycle_path)
    saveRDS(cyc_city, cycle_path)
  }
  
  if (nrow(cyc_city) == 0) {
    return(tibble(
      country           = country_name,
      city_name         = city_name,
      total_cycle_km    = 0,
      off_road_km       = 0,
      segregated_wide_km = 0,
      segregated_narrow_km = 0,
      painted_km        = 0,
      shared_footway_km = 0
    ))
  }

  # Classify
  cyc_classified <- tryCatch({
    osmactive::classify_cycle_infrastructure(cyc_city)
  }, error = function(e) {
    warning("Classification failed for ", city_name, ": ", e$message)
    cyc_city$cycle_segregation <- NA_character_
    cyc_city
  })

  # Calculate lengths
  cyc_classified$length_m <- sf::st_length(cyc_classified)
  
  # Summarise
  summary <- cyc_classified |>
    sf::st_drop_geometry() |>
    group_by(cycle_segregation) |>
    summarise(len_km = sum(as.numeric(length_m), na.rm = TRUE) / 1000) |>
    ungroup()
  
  get_len <- function(cat) {
    val <- summary$len_km[summary$cycle_segregation == cat]
    if (length(val) == 0 || is.na(val)) 0 else val
  }

  tibble(
    country           = country_name,
    city_name         = city_name,
    total_cycle_km    = sum(as.numeric(cyc_classified$length_m), na.rm = TRUE) / 1000,
    off_road_km       = get_len("Off Road Path"),
    segregated_wide_km = get_len("Segregated Track (wide)"),
    segregated_narrow_km = get_len("Segregated Track (narrow)"),
    painted_km        = get_len("Painted Cycle Lane"),
    shared_footway_km = get_len("Shared Footway")
  )
}

```

```{r}
#| label: download-and-update-city-lengths
#| eval: true
#| include: false

# 0. All cities present in the QoL data
cities_all <- all_cities |>
  select(country, city_name) |>
  distinct() |>
  mutate(across(everything(), as.character)) |>
  arrange(country, city_name)

# 1. Load previous city lengths if they exist
if (file.exists("outputs/city_lengths_all.csv")) {
  city_lengths_all <- read_csv("outputs/city_lengths_all.csv", show_col_types = FALSE)
  cols_to_add <- c("off_road_km", "segregated_wide_km", "segregated_narrow_km", "painted_km", "shared_footway_km")
  for (col in cols_to_add) {
    if (!col %in% names(city_lengths_all)) {
      city_lengths_all[[col]] <- NA_real_
    }
  }
} else {
  city_lengths_all <- tibble(
    country           = character(),
    city_name         = character(),
    total_cycle_km    = numeric(),
    off_road_km       = numeric(),
    segregated_wide_km = numeric(),
    segregated_narrow_km = numeric(),
    painted_km        = numeric(),
    shared_footway_km = numeric()
  )
}

# 2. Work out which cities already have lengths in the RDS (with new columns)
if ("off_road_km" %in% names(city_lengths_all)) {
  cities_done <- city_lengths_all |>
    filter(!is.na(off_road_km)) |>
    select(country, city_name)
} else {
  cities_done <- tibble(country = character(), city_name = character())
}

cities_todo <- cities_all |>
  anti_join(cities_done, by = c("country", "city_name"))

message("Cities to process: ", nrow(cities_todo))

# 3. Loop over remaining cities, saving as we go
if (nrow(cities_todo) > 0) {
  dir.create("outputs", showWarnings = FALSE)

  start_time <- Sys.time()
  
  for (i in seq_len(nrow(cities_todo))) {
    cty <- cities_todo$country[i]
    city <- cities_todo$city_name[i]
    
    res <- try({
      get_city_metrics(city, cty)
    }, silent = TRUE)

    if (inherits(res, "try-error")) {
      warning("Failed for ", city, ": ", conditionMessage(attr(res, "condition")))
      next
    }
    
    if (is.null(res)) next

    # Update combined table and save after each city
    city_lengths_all <- city_lengths_all |>
        filter(!(country == cty & city_name == city)) |>
        bind_rows(res)

    write_csv(city_lengths_all, "outputs/city_lengths_all.csv")
    message("Saved updated city_lengths_all.csv")
  }
  
  end_time <- Sys.time()
  timing_msg <- paste0("Processed ", nrow(cities_todo), " cities in ", round(as.numeric(difftime(end_time, start_time, units = "secs")), 2), " seconds.")
  message(timing_msg)
} else {
  message("No new cities to process. All done.")
}
city_lengths_all
```

```{r}
#| label: test-classification
#| eval: false

# Test the classification logic on a small country/city (Monaco)
message("Running classification test for Monaco...")
# We use try() to allow the document to render even if the test fails (e.g. internet issues)
test_result <- try({
  get_city_metrics("Monaco", "Monaco")
}, silent = TRUE)

if (inherits(test_result, "try-error")) {
  message("Test failed: ", conditionMessage(attr(test_result, "condition")))
} else {
  print(test_result)
}
```

## Results

```{r}
#| label: analysis-test
#| include: false

test_countries <- c(
  "Albania",
  "Austria",
  "Belgium",
  "Bulgaria",
  "Croatia",
  "Cyprus",
  "Czech Republic",
  "Denmark",
  "Estonia",
  "Finland",
  "France",
  "Greece",
  "Hungary",
  "Iceland",
  "Ireland",
  "Italy",
  "Latvia",
  "Lithuania",
  "Luxembourg",
  "Macedonia",
  "Malta",
  "Montenegro",
  "Netherlands",
  "Poland",
  "Portugal",
  "Romania",
  "Serbia",
  "Slovakia",
  "Slovenia",
  "Spain",
  "Sweden",
  "Switzerland",
  "Turkey")

test_cities <- all_cities |>
  filter(country %in% test_countries)

dir.create("outputs", showWarnings = FALSE)

city_lengths_all <- read_csv("outputs/city_lengths_all.csv", show_col_types = FALSE)

analysis_test <- test_cities |>
  left_join(
    city_lengths_all,
    by = c("country", "city_name")
  ) |>
  mutate(
    bike_share_pct    = bike_prop * 100,
    infra_km_per_1000 = total_cycle_km / (population / 1000)
  )

analysis_test |>
  select(country, city_name, population, bike_share_pct, infra_km_per_1000)
```

```{r}
#| echo: false
#| message: false
#| warning: false
#| paged-print: false

# Prepare data for plotting
plot_data <- analysis_test |>
  filter(
    !is.na(total_cycle_km),
    !is.na(bike_share_pct),
    population > 100000,
    country != "Turkey"
  ) 

# Create long format for faceting
plot_data_long <- plot_data |>
  pivot_longer(
    cols = c(total_cycle_km, off_road_km, segregated_wide_km, segregated_narrow_km, painted_km, shared_footway_km),
    names_to = "infra_type",
    values_to = "km"
  ) |>
  mutate(
    km_per_1000 = km / (population / 1000),
    infra_type_label = factor(infra_type, 
      levels = c("total_cycle_km", "segregated_wide_km", "segregated_narrow_km", "off_road_km", "painted_km", "shared_footway_km"),
      labels = c("Total", "Segregated (wide)", "Segregated (narrow)", "Off-road paths", "Painted lanes", "Shared footways")
    )
  ) |>
  filter(km_per_1000 <= 30) # Filter extreme outliers if necessary

set.seed(123)

scatter_plot <- ggplot(
  plot_data_long,
  aes(
    x      = km_per_1000,
    y      = bike_share_pct,
    size   = population,
    colour = country
  )
) +
  geom_point(alpha = 0.6) +
  geom_smooth(method = "lm", se = FALSE,
              colour = "grey40", linewidth = 0.5, linetype = "dashed") +
  facet_wrap(~infra_type_label, scales = "free_x") +
  ggrepel::geom_text_repel(
    aes(label = city_name),
    size         = 2.5,
    show.legend  = FALSE,
    max.overlaps = 10
  ) +
  scale_size_continuous(
    name   = "Population",
    labels = scales::label_number(scale_cut = scales::cut_short_scale()),
    range  = c(1, 4),
    guide  = guide_legend(override.aes = list(alpha = 1, colour = "grey60"))
  ) +
  labs(
    x = "Infrastructure (km per 1 000 residents)",
    y = "Cycling mode share (%)",
    colour = "Country",
    title  = "Cycling levels vs. Infrastructure Types"
  ) +
  theme_minimal(base_size = 11) +
  theme(
    plot.title       = element_text(face = "bold"),
    panel.grid.minor = element_blank(),
    legend.position  = "bottom",
    strip.text       = element_text(face = "bold")
  )

scatter_plot

dir.create("figs", showWarnings = FALSE)
ggsave("figs/scatter_plot.png", bg = "white", width = 10, height = 7)

# Correlation coefficients by type
message("R-squared values by infrastructure type:")
cor_data <- plot_data_long |>
  group_by(infra_type_label) |>
  summarise(
    r_squared = round(cor(km_per_1000, bike_share_pct, use = "complete.obs")^2, 3),
    n_cities = n()
  )
print(cor_data)
```

## Next steps

-   Check city boundaries and cases with missing or zero cycling infrastructure (e.g. Spanish, Irish, and Finish cities).

-   Standardise city names in English.

-   Address download issues for large countries (Germany and the UK).
    Also Ireland downloading, currently it seems to download Iceland

-   Expand the set of simple metrics (e.g. cycling network/area or total network).

-   Fit basic regression models to examine how different infrastructure metrics relate to cycling use.