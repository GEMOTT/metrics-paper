---
title: "Preliminary cycling infra vs usage analysis"
format: gfm
---

## Introduction

-   Aim: examine which cycling-infrastructure metrics align best with cycling use.

-   Start with simple measures (total km, km per 1 000 people) -- foundation for later work on network characteristics.

## Data and methods

-   Cycling infrastructure from OSM, `osmactive` R package. We classified infrastructure into distinct categories using the `classify_cycle_infrastructure` function, which considers OSM tags (e.g., `highway`, `cycleway`, `segregated`) and geometry (e.g., distance to the nearest road) to distinguish between:
    -   **Segregated tracks:** Physically separated from motor traffic (further split into wide $\ge$ 2m and narrow < 2m).
    -   **Off-road paths:** Paths away from the road network (e.g., through parks).
    -   **Painted lanes:** Marked lanes on the carriageway without physical separation.
    -   **Shared footways:** Paths shared with pedestrians.
    -   **Mixed traffic:** Cycling on the carriageway with motor traffic (not counted as dedicated infrastructure).

-   Cycling use from [the EU Quality of Life Survey](https://ec.europa.eu/regional_policy/information-sources/maps/quality-of-life_en).
    83 cities, ≈ 70,000 respondents; includes a transport question (“On a typical day, which mode(s) of transport do you use most often?”
    ), where cycling is one of the selectable modes (up to two choices allowed), providing a simple city-level proxy for cycling use.
    There are previous editions.

-   Create exploratory scatter plots to see associations.

<!-- ### Potential cycling-use datasets -->

<!-- - **Eurostat: journeys to work by bicycle**   -->

<!--   Patchy coverage, many cities missing.   -->

<!--   https://ec.europa.eu/eurostat/databrowser/view/urb_ctran__custom_18909106/default/table -->

<!-- - **Bicycle counter data (Kraus and Koch, PNAS)**   -->

<!--   Only for cities with counters.   -->

<!--   https://www.pnas.org/doi/10.1073/pnas.2024399118   -->

<!--   Data: https://zenodo.org/records/4015974 -->

<!-- - **Cycling mode share in 864 European cities (Sobral et al.)**   -->

<!--   Interesting working project, modelled values.   -->

<!--   https://www.cyclingandsociety.org/wp-content/uploads/2025/09/CyclingAndSociety2025-4-Sobral.pdf -->

<!-- - **Quality of Life in European Cities survey (DG REGIO)**   -->

<!--   83 cities, >70,000 respondents; includes question   -->

<!--   “On a typical day, which mode(s) do you use most often? Bicycle”.   -->

<!--   https://ec.europa.eu/regional_policy/information-sources/maps/quality-of-life_en -->

<!-- *the QoL survey seems to provide the most consistent city-level cycling-use indicator across many cities. IS 83 sample enough?* -->

```{r}
#| label: setup
#| include: false
library(tidyverse) 
library(sf)
library(osmdata)
library(osmactive)
library(ggrepel)
library(scales)
library(knitr)   
```

```{r}
#| include: false

# install.packages("haven")  # SPSS file
library(haven)

qol <- read_sav("data/QoL in European Cities_2023_microdata/2023_QoL in European Cities_microdata.sav")

qol_factor <- qol |>
  mutate(across(where(is.labelled), ~ as_factor(.)))

qol_q5 <- qol_factor |>
  group_by(country   = Country_sample,
           city_name = D3_Cityrecode,
           population = Population) |>
  summarise(
    bike_sample = sum(w1[Q5_1 == "Bicycle" | Q5_2 == "Bicycle"], na.rm = TRUE),
    total_sample    = sum(w1, na.rm = TRUE),
    bike_prop     = bike_sample / total_sample
  ) |>
  arrange(desc(bike_prop))
```

```{r}
#| label: cities-qol
#| include: false

all_cities <- qol_q5 |>
  mutate(
    city_name = as.character(city_name),
    country   = as.character(country)
  ) |>
  arrange(desc(bike_prop))

```

```{r}
#| label: osm-cache-helpers
#| include: false
if (!dir.exists("/media/eugeni/Extrem SSD/my-stuff/metrics-paper/data")) {
  cache_dir <- "data/cache/osm_cache"
  dir.create(cache_dir, showWarnings = FALSE, recursive = TRUE)
} else {
  cache_dir <- "/media/eugeni/Extrem SSD/my-stuff/metrics-paper/data/osm_cache"
}

osm_country_path <- function(country) {
  str_glue("{cache_dir}/osm_{country}.rds")
}

cycle_country_path <- function(country) {
  str_glue("{cache_dir}/cycle_{country}.rds")
}


get_country_osm_cached <- function(country_name) {
  path <- osm_country_path(country_name)

  if (file.exists(path)) {
    message("Reading cached OSM for ", country_name, " from ", path)
    readRDS(path)
  } else {
    message("Downloading OSM for ", country_name)
    osm <- osmactive::get_travel_network(country_name)
    message("Saving OSM cache to ", path)
    saveRDS(osm, path)
    osm
  }
}

get_country_cycle_cached <- function(country_name) {
  path <- cycle_country_path(country_name)

  if (file.exists(path)) {
    message("Reading cached cycling network for ", country_name, " from ", path)
    readRDS(path)
  } else {
    osm   <- get_country_osm_cached(country_name)
    cycle <- osmactive::get_cycling_network(osm)

    cycle$length_m <- sf::st_length(cycle)

    message("Saving cycle cache to ", path)
    saveRDS(cycle, path)
    cycle
  }
}

```

```{r}
#| label: city-tools
#| include: false
get_city_polygon <- function(city, country) {
  query <- paste(city, country, sep = ", ")
  message("  Boundary for: ", query)

  poly <- tryCatch(
    osmdata::getbb(query, format_out = "sf_polygon"),
    error = function(e) NULL
  )

  if (inherits(poly, "sf")) {
    message("    Got polygon boundary for ", query)
  } else {
    message("    No polygon boundary for ", query, "; trying bounding box")
    bb <- osmdata::getbb(query)
    if (is.null(bb)) {
      warning("    No boundary found for ", query)
      return(NULL)
    }

    poly <- sf::st_as_sf(
      sf::st_sfc(
        sf::st_polygon(list(rbind(
          c(bb["x", "min"], bb["y", "min"]),
          c(bb["x", "min"], bb["y", "max"]),
          c(bb["x", "max"], bb["y", "max"]),
          c(bb["x", "max"], bb["y", "min"]),
          c(bb["x", "min"], bb["y", "min"])
        ))),
        crs = 4326
      )
    )
  }

  # Calculate area
  area_sq_km <- sum(as.numeric(sf::st_area(poly))) / 1e6

  message("    Area: ", round(area_sq_km, 2), " km sq")

  if (area_sq_km > 1000) {
    message("    Area > 1000 km sq. Clipping to 25km radius from centroid.")

    # Find centroid of the union (in case of multiple polygons)
    centroid <- sf::st_centroid(sf::st_union(poly))

    # Create 25km buffer
    buffer <- sf::st_buffer(centroid, dist = 25000)

    # Intersect
    poly <- sf::st_intersection(poly, buffer)
  }

  return(poly)
}

get_city_lengths_for_country <- function(country_name, cities_df) {
  message("=== Country: ", country_name, " ===")

  cycle_net_country <- get_country_cycle_cached(country_name)
  # Also load full OSM to identify roads for distance calculation
  osm_country <- get_country_osm_cached(country_name)
  
  # Filter for "car roads" to calculate distance from
  car_roads_country <- osm_country |>
    filter(highway %in% c("motorway", "motorway_link", "trunk", "trunk_link", 
                          "primary", "primary_link", "secondary", "secondary_link", 
                          "tertiary", "tertiary_link", "unclassified", "residential"))

  cities_country <- cities_df |>
    filter(country == country_name)

  map_dfr(seq_len(nrow(cities_country)), function(i) {
    city <- cities_country$city_name[i]

    message("City: ", city)

    poly <- get_city_polygon(city, country_name)
    if (is.null(poly)) {
      return(tibble(
        country           = country_name,
        city_name         = city,
        total_cycle_km    = NA_real_,
        off_road_km       = NA_real_,
        segregated_wide_km = NA_real_,
        segregated_narrow_km = NA_real_,
        painted_km        = NA_real_,
        shared_footway_km = NA_real_
      ))
    }

    # Intersect cycle network
    cyc_city <- suppressWarnings(sf::st_intersection(cycle_net_country, poly))
    
    if (nrow(cyc_city) == 0) {
      return(tibble(
        country           = country_name,
        city_name         = city,
        total_cycle_km    = 0,
        off_road_km       = 0,
        segregated_wide_km = 0,
        segregated_narrow_km = 0,
        painted_km        = 0,
        shared_footway_km = 0
      ))
    }

    # Intersect roads (for distance calc)
    roads_city <- suppressWarnings(sf::st_intersection(car_roads_country, poly))
    
    # Calculate distance to nearest road
    # (Required for classify_cycle_infrastructure)
    if (nrow(roads_city) > 0) {
      pts <- sf::st_point_on_surface(cyc_city)
      nearest_idx <- sf::st_nearest_feature(pts, roads_city)
      dists <- sf::st_distance(pts, roads_city[nearest_idx,], by_element = TRUE)
      cyc_city$distance_to_road <- as.numeric(dists)
    } else {
      # If no roads found (unlikely), assume far away? Or 0?
      # Default to 0 to be safe (not off-road) unless explicitly defined
      cyc_city$distance_to_road <- 0 
    }

    # Classify
    # Catch errors in classification to avoid stopping the whole loop
    cyc_classified <- tryCatch({
      osmactive::classify_cycle_infrastructure(cyc_city)
    }, error = function(e) {
      warning("Classification failed for ", city, ": ", e$message)
      cyc_city$cycle_segregation <- NA_character_
      cyc_city
    })

    # Calculate lengths
    cyc_classified$length_m <- sf::st_length(cyc_classified)
    
    # Summarise
    summary <- cyc_classified |>
      sf::st_drop_geometry() |>
      group_by(cycle_segregation) |>
      summarise(len_km = sum(as.numeric(length_m), na.rm = TRUE) / 1000) |>
      ungroup()
    
    # Extract specific categories
    # Categories from osmactive: "Segregated Track (wide)", "Segregated Track (narrow)", 
    # "Off Road Path", "Shared Footway", "Painted Cycle Lane"
    
    get_len <- function(cat) {
      val <- summary$len_km[summary$cycle_segregation == cat]
      if (length(val) == 0 || is.na(val)) 0 else val
    }

    tibble(
      country           = country_name,
      city_name         = city,
      total_cycle_km    = sum(as.numeric(cyc_classified$length_m), na.rm = TRUE) / 1000,
      off_road_km       = get_len("Off Road Path"),
      segregated_wide_km = get_len("Segregated Track (wide)"),
      segregated_narrow_km = get_len("Segregated Track (narrow)"),
      painted_km        = get_len("Painted Cycle Lane"),
      shared_footway_km = get_len("Shared Footway")
    )
  })
}

```

```{r}
#| label: download-and-update-city-lengths
#| eval: true
#| include: false

# 0. All countries present in the QoL data
countries_all <- sort(unique(all_cities$country))

# 1. Load previous city lengths if they exist
if (file.exists("outputs/city_lengths_all.rds")) {
  city_lengths_all <- readRDS("outputs/city_lengths_all.rds")
  # Ensure new columns exist if reading from old file
  cols_to_add <- c("off_road_km", "segregated_wide_km", "segregated_narrow_km", "painted_km", "shared_footway_km")
  for (col in cols_to_add) {
    if (!col %in% names(city_lengths_all)) {
      city_lengths_all[[col]] <- NA_real_
    }
  }
} else {
  city_lengths_all <- tibble(
    country           = character(),
    city_name         = character(),
    total_cycle_km    = numeric(),
    off_road_km       = numeric(),
    segregated_wide_km = numeric(),
    segregated_narrow_km = numeric(),
    painted_km        = numeric(),
    shared_footway_km = numeric()
  )
}

# 2. Work out which countries already have lengths in the RDS
# We check which countries have the new 'off_road_km' column populated
if ("off_road_km" %in% names(city_lengths_all)) {
  countries_done <- city_lengths_all |>
    filter(!is.na(off_road_km)) |>
    pull(country) |>
    unique() |>
    sort()
} else {
  countries_done <- character(0)
}

countries_todo <- setdiff(countries_all, countries_done)

countries_all
countries_done
countries_todo

# 3. Loop over remaining countries, saving as we go
if (length(countries_todo) > 0) {
  dir.create("outputs", showWarnings = FALSE)

  for (cty in countries_todo) {
    message("=== Processing country: ", cty, " ===")

    res <- try(
      get_city_lengths_for_country(cty, all_cities),
      silent = TRUE
    )

    if (inherits(res, "try-error")) {
      warning("Failed for ", cty, ": ", conditionMessage(attr(res, "condition")))
      next
    }

    # Update combined table and save after each country
    # Remove old entries for this country if they exist (for re-running)
    city_lengths_all <- city_lengths_all |>
        filter(country != cty) |>
        bind_rows(res) |>
        distinct(country, city_name, .keep_all = TRUE)

    saveRDS(city_lengths_all, "outputs/city_lengths_all.rds")
    message("Saved updated city_lengths_all.rds (", nrow(city_lengths_all), " rows)")
  }
} else {
  message("No new countries to process. All done.")
}
city_lengths_all
```

```{r}
#| label: test-classification
#| eval: false

# Test the classification logic on a small country/city (Monaco)
test_city_df <- tibble(
  country = "Monaco",
  city_name = "Monaco"
)

message("Running classification test for Monaco...")
# We use try() to allow the document to render even if the test fails (e.g. internet issues)
test_result <- try({
  get_city_lengths_for_country("Monaco", test_city_df)
}, silent = TRUE)

if (inherits(test_result, "try-error")) {
  message("Test failed: ", conditionMessage(attr(test_result, "condition")))
} else {
  print(test_result)
}
```

## Results

```{r}
#| label: analysis-test
#| include: false

test_countries <- c(
  "Albania",
  "Austria",
  "Belgium",
  "Bulgaria",
  "Croatia",
  "Cyprus",
  "Czech Republic",
  "Denmark",
  "Estonia",
  "Finland",
  "France",
  "Greece",
  "Hungary",
  "Iceland",
  "Ireland",
  "Italy",
  "Latvia",
  "Lithuania",
  "Luxembourg",
  "Macedonia",
  "Malta",
  "Montenegro",
  "Netherlands",
  "Poland",
  "Portugal",
  "Romania",
  "Serbia",
  "Slovakia",
  "Slovenia",
  "Spain",
  "Sweden",
  "Switzerland",
  "Turkey")

test_cities <- all_cities |>
  filter(country %in% test_countries)

dir.create("outputs", showWarnings = FALSE)

city_lengths_all <- readRDS("outputs/city_lengths_all.rds")

analysis_test <- test_cities |>
  left_join(
    city_lengths_all,
    by = c("country", "city_name")
  ) |>
  mutate(
    bike_share_pct    = bike_prop * 100,
    infra_km_per_1000 = total_cycle_km / (population / 1000)
  )

analysis_test |>
  select(country, city_name, population, bike_share_pct, infra_km_per_1000)
```

```{r}
#| echo: false
#| message: false
#| warning: false
#| paged-print: false

plot_data <- analysis_test |>
  filter(
    !is.na(infra_km_per_1000),
    !is.na(bike_share_pct),
    infra_km_per_1000 <= 10,
    population > 500000,
    country != "Turkey"# some cities boundaries seem wrong -- too much infra! We need to solve this
)

set.seed(123)

scatter_plot <- ggplot(
  plot_data,
  aes(
    x      = infra_km_per_1000,
    y      = bike_share_pct,
    size   = population,
    colour = country
  )
) +
  geom_point(alpha = 0.75) +
  geom_smooth(method = "lm", se = FALSE,
              colour = "grey40", linewidth = 0.5, linetype = "dashed") +
  ggrepel::geom_text_repel(
    aes(label = city_name),
    size         = 3,
    show.legend  = FALSE,
    max.overlaps = 20
  ) +
  scale_size_continuous(
    name   = "Population",
    labels = scales::label_number(scale_cut = scales::cut_short_scale()),
    range  = c(2, 9),
    guide  = guide_legend(override.aes = list(alpha = 1, colour = "grey60"))
  ) +
  labs(
    x = "Cycling infrastructure (km per 1 000 residents)",
    y = "Cycling as main mode (%)",
    colour = "Country",
    title  = "Cycling levels and cycling infrastructure"
  ) +
  theme_minimal(base_size = 11) +
  theme(
    plot.title       = element_text(face = "bold"),
    panel.grid.minor = element_blank()
  )

scatter_plot

dir.create("figs", showWarnings = FALSE)

ggsave("figs/scatter_plot.png", bg = "white")

# Correlation coefficient
cor_coef <- cor(
  plot_data$infra_km_per_1000,
  plot_data$bike_share_pct,
  method = "pearson",
  use    = "complete.obs"
)
cor_coef^2
```

## Next steps

-   Check city boundaries and cases with missing or zero cycling infrastructure (e.g. Spanish, Irish, and Finish cities).

-   Standardise city names in English.

-   Address download issues for large countries (Germany and the UK).
    Also Ireland downloading, currently it seems to download Iceland

-   Expand the set of simple metrics (e.g. cycling network/area or total network).

-   Fit basic regression models to examine how different infrastructure metrics relate to cycling use.